import re, sys

# --- Config: enharmonic mapping and circle of fifths ---
ENHARMONIC = {
    'Bb': 'A#', 'Cb': 'B', 'Db': 'C#', 'Eb': 'D#', 'Fb': 'E',
        'Gb': 'F#', 'Ab': 'G#'
        }
        CIRCLE = ['C', 'G', 'D', 'A', 'E', 'B', 'F#', 'C#', 'G#', 'D#', 'A#', 'F']

        # --- Utilities ---
        def normalize_note(note):
            """Convert flats to sharps, uppercase."""
                note = note.capitalize()
                    return ENHARMONIC.get(note, note)

                    def chord_root(chord):
                        """Extract root (letter + optional #/b) from chord string."""
                            m = re.match(r'^([A-G][b#]?)(.*)', chord)
                                return normalize_note(m.group(1)) if m else None

                                def nfc_steps(chords, base):
                                    """Compute NFC steps for each chord root from base note."""
                                        b = CIRCLE.index(normalize_note(base))
                                            path = []
                                                for c in chords:
                                                        r = chord_root(c)
                                                                if r not in CIRCLE:
                                                                            print(f"Warning: '{c}' → root '{r}' not in Circle, skipping.")
                                                                                        continue
                                                                                                idx = CIRCLE.index(r)
                                                                                                        path.append((idx - b) % 12)
                                                                                                            return path

                                                                                                            # --- Feature Extraction ---
                                                                                                            def peak_tension(path): return max(path) if path else 0
                                                                                                            def spread(path): return (max(path) - min(path)) if path else 0
                                                                                                            def return_to_tonic(path): return 1 if 0 in path else 0

                                                                                                            # Hyperparameter scoring (1–10)
                                                                                                            def score_threshold_attention(path):
                                                                                                                diffs = [abs(path[i+1] - path[i]) for i in range(len(path)-1)]
                                                                                                                    avg = sum(diffs)/len(diffs) if diffs else 0
                                                                                                                        return round((avg/6)*9 + 1)

                                                                                                                        def score_harmonic_expansion(path):
                                                                                                                            return round((spread(path)/6)*9 + 1)

                                                                                                                            def score_unnecessary_disruption(path):
                                                                                                                                diffs = [abs(path[i+1] - path[i]) for i in range(len(path)-1)]
                                                                                                                                    disrupts = sum(1 for d in diffs if d >= 3)
                                                                                                                                        ratio = disrupts / (len(diffs) or 1)
                                                                                                                                            return round(ratio*9 + 1)

                                                                                                                                            def score_emotional_saturation(path):
                                                                                                                                                diffs = [abs(path[i+1] - path[i]) for i in range(len(path)-1)]
                                                                                                                                                    small = sum(1 for d in diffs if d <= 1)
                                                                                                                                                        ratio = small / (len(diffs) or 1)
                                                                                                                                                            return round(ratio*9 + 1)

                                                                                                                                                            def score_compression_tension(path):
                                                                                                                                                                diffs = [path[i+1] - path[i] for i in range(len(path)-1)]
                                                                                                                                                                    climbs = sum(1 for d in diffs if d > 0)
                                                                                                                                                                        ratio = climbs / (len(diffs) or 1)
                                                                                                                                                                            return round(ratio*9 + 1)

                                                                                                                                                                            def score_interference_memory(path):
                                                                                                                                                                                seen = set()
                                                                                                                                                                                    repeats = 0
                                                                                                                                                                                        for p in path:
                                                                                                                                                                                                if p in seen:
                                                                                                                                                                                                            repeats += 1
                                                                                                                                                                                                                    seen.add(p)
                                                                                                                                                                                                                        ratio = repeats / (len(path) or 1)
                                                                                                                                                                                                                            return round(ratio*9 + 1)

                                                                                                                                                                                                                            def score_semantic_resonance(path):
                                                                                                                                                                                                                                if path and path[0]==0 and path[-1]==0: return 10
                                                                                                                                                                                                                                    if 0 in path: return 6
                                                                                                                                                                                                                                        return 2

                                                                                                                                                                                                                                        def score_ego_quotation(path):
                                                                                                                                                                                                                                            pivots = sum(1 for p in path if p in (1,5))
                                                                                                                                                                                                                                                ratio = pivots / (len(path) or 1)
                                                                                                                                                                                                                                                    return round(ratio*9 + 1)

                                                                                                                                                                                                                                                    def score_temporal_modularity(path):
                                                                                                                                                                                                                                                        # loops = number of times we return to a previous NFC (excluding tonic)
                                                                                                                                                                                                                                                            loops = sum(1 for i,p in enumerate(path) if p in path[:i])
                                                                                                                                                                                                                                                                ratio = loops / (len(path) or 1)
                                                                                                                                                                                                                                                                    return round(ratio*9 + 1)

                                                                                                                                                                                                                                                                    def score_recursive_learning(path):
                                                                                                                                                                                                                                                                        return 10 if path and path[-1]==0 else 5

                                                                                                                                                                                                                                                                        def score_volitional_loop(path):
                                                                                                                                                                                                                                                                            # intentional inversion: large jump to tonic
                                                                                                                                                                                                                                                                                jumps = [abs(path[i+1] - path[i]) for i in range(len(path)-1)]
                                                                                                                                                                                                                                                                                    inversion = any(j>=6 for j in jumps)
                                                                                                                                                                                                                                                                                        return 10 if inversion else 4

                                                                                                                                                                                                                                                                                        # --- Main ---
                                                                                                                                                                                                                                                                                        def main():
                                                                                                                                                                                                                                                                                            base = input("Base key (e.g. F): ").strip() or 'F'
                                                                                                                                                                                                                                                                                                inp = input("Chords (space-separated): ").strip()
                                                                                                                                                                                                                                                                                                    chords = inp.split()
                                                                                                                                                                                                                                                                                                        path = nfc_steps(chords, base)
                                                                                                                                                                                                                                                                                                            print("\n--- NFC Path ---")
                                                                                                                                                                                                                                                                                                                print(path)

                                                                                                                                                                                                                                                                                                                    # Features
                                                                                                                                                                                                                                                                                                                        p_t = peak_tension(path)
                                                                                                                                                                                                                                                                                                                            sp = spread(path)
                                                                                                                                                                                                                                                                                                                                rtn = return_to_tonic(path)

                                                                                                                                                                                                                                                                                                                                    print(f"\nPeak Tension: {p_t} fc")
                                                                                                                                                                                                                                                                                                                                        print(f"Spread: {sp} fc")
                                                                                                                                                                                                                                                                                                                                            print(f"Return to tonic: {'Yes' if rtn else 'No'}")

                                                                                                                                                                                                                                                                                                                                                # Compute HP scores
                                                                                                                                                                                                                                                                                                                                                    scores = {
                                                                                                                                                                                                                                                                                                                                                            "Threshold Attention": score_threshold_attention(path),
                                                                                                                                                                                                                                                                                                                                                                    "Harmonic Expansion": score_harmonic_expansion(path),
                                                                                                                                                                                                                                                                                                                                                                            "Unnecessary Disruption": score_unnecessary_disruption(path),
                                                                                                                                                                                                                                                                                                                                                                                    "Emotional Saturation": score_emotional_saturation(path),
                                                                                                                                                                                                                                                                                                                                                                                            "Compression Tension": score_compression_tension(path),
                                                                                                                                                                                                                                                                                                                                                                                                    "Interference Memory": score_interference_memory(path),
                                                                                                                                                                                                                                                                                                                                                                                                            "Semantic Resonance": score_semantic_resonance(path),
                                                                                                                                                                                                                                                                                                                                                                                                                    "Ego Quotation": score_ego_quotation(path),
                                                                                                                                                                                                                                                                                                                                                                                                                            "Death Entropy":  # approximate as spread-related
                                                                                                                                                                                                                                                                                                                                                                                                                                        round((p_t/6)*9 + 1),
                                                                                                                                                                                                                                                                                                                                                                                                                                                "Temporal Modularity": score_temporal_modularity(path),
                                                                                                                                                                                                                                                                                                                                                                                                                                                        "Recursive Learning": score_recursive_learning(path),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                "Volitional Loop": score_volitional_loop(path)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                    }

                                                                                                                                                                                                                                                                                                                                                                                                                                                                        # Print Scorecard
                                                                                                                                                                                                                                                                                                                                                                                                                                                                            print("\n--- BIWA HP Scorecard (1–10) ---")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                for k,v in scores.items():
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        print(f"{k:25s}: {v}/10")

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            avg = sum(scores.values()) / len(scores)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                print(f"\nOverall BIWA Coherence: {avg:.1f}/10")

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                if __name__ == "__main__":
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    main()